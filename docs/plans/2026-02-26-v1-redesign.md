# v1.0 redesign â€” full implementation plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.
> Each task ends with a build/test step and a commit. Do not skip verification steps.
> Read CLAUDE.md before starting â€” British English, sentence case, no Oxford comma.

## Progress (updated 2026-02-26)

âœ… Task 1 â€” commit 32c79e1
âœ… Task 2 â€” commit f9bf40b
âœ… Task 3 â€” commit 3a47c8e
âœ… Task 4 â€” commit 0011284
âœ… Task 5 â€” commit 4554154
âœ… Task 6 â€” commit f1dca2c
âœ… Task 7 â€” commit 25c5e87
âœ… Task 8 + 12 â€” commit 0893159 (folded together â€” App.xaml.cs fully wired)
âœ… Task 9 â€” commit 7ebeb49
â¬œ **Task 10 â€” NEXT** (orphaned files details window)
â¬œ Task 11 (settings dialog)
â¬œ Task 13 (registered files details window)
â¬œ Task 14 (MSI summary info in detail windows)
â¬œ Task 15 (polish + final verification)
â¬œ Task 16 (update tests)

17 tests passing. Branch: main.

**Author:** Opus, 26 February 2026
**Goal:** Transform the current broken prototype into a shippable v1.0 that matches PatchCleaner's feature set with modern technology. Release target: 3 March 2026.

**Key architectural decisions (already made â€” do not revisit):**
- Drop Phase 2 (component scan) entirely â€” Phase 1 is sufficient
- Exclusion filters (not warnings) for Adobe/problematic files
- Compact summary main window (~700Ã—300), not a file list
- Auto-scan on startup
- Move primary, Delete secondary (with confirmation)
- Settings in `AppData\Local\NoFaff\SimpleWindowsInstallerCleaner\settings.json`
- OLE Summary Information Stream via MSI API P/Invoke (`MsiGetSummaryInformation`)
- Framework-dependent single-file distribution (small exe, requires .NET 8 runtime)

---

## What already exists (do not recreate)

```
src/SimpleWindowsInstallerCleaner/
  Interop/MsiConstants.cs, MsiNativeMethods.cs     â† P/Invoke (will be modified)
  Models/RegisteredPackage.cs, OrphanedFile.cs      â† records (will be modified)
  Services/                                         â† all service interfaces + implementations
  ViewModels/MainViewModel.cs, OrphanedFileViewModel.cs  â† (will be rewritten)
  MainWindow.xaml, MainWindow.xaml.cs               â† (will be rewritten)
  App.xaml, App.xaml.cs                             â† composition root (will be modified)
src/SimpleWindowsInstallerCleaner.Tests/            â† 7 passing tests (will be modified)
```

---

## Task 1: Strip Phase 2 from InstallerQueryService

**Why:** Phase 2 is O(components Ã— products) and takes 3+ minutes. It's unnecessary â€” Phase 1 catches all registrations that matter.

**Files to modify:**
- `src/SimpleWindowsInstallerCleaner/Services/InstallerQueryService.cs`
- `src/SimpleWindowsInstallerCleaner/Interop/MsiNativeMethods.cs`
- `src/SimpleWindowsInstallerCleaner/Interop/MsiConstants.cs`
- `src/SimpleWindowsInstallerCleaner/Models/RegisteredPackage.cs`
- `src/SimpleWindowsInstallerCleaner/Services/FileSystemScanService.cs`
- `src/SimpleWindowsInstallerCleaner/Models/OrphanedFile.cs`
- `src/SimpleWindowsInstallerCleaner.Tests/Services/FileSystemScanServiceTests.cs`

**Changes:**

1. **InstallerQueryService.cs** â€” Delete all Phase 2 code:
   - Delete the entire Phase 2 section in `GetRegisteredPackagesCore()` (lines 96â€“121: the comment block, `EnumerateComponentPathsInInstallerFolder` call, and the foreach loop)
   - Delete `EnumerateComponentPathsInInstallerFolder()` method (lines 282â€“334)
   - Delete `GetComponentSid()` method (lines 340â€“370)
   - Delete `GetComponentPath()` method (lines 376â€“409)
   - Delete `FindOwningProduct()` method (lines 415â€“459)
   - Remove the `InstallerFolderPrefix` field (lines 32â€“34) â€” only used by Phase 2
   - Update the final progress report to not mention "Scan complete" differently

2. **MsiNativeMethods.cs** â€” Delete:
   - `MsiEnumComponentsEx` declaration (lines 171â€“179)
   - `MsiGetComponentPathEx` declaration (lines 199â€“206)
   - `InstallStateLocal` and `InstallStateSource` constants (lines 212â€“213)

3. **MsiConstants.cs** â€” Delete:
   - `MsiComponentClient` static class (lines 67â€“77) â€” only used by Phase 2

4. **RegisteredPackage.cs** â€” Remove `IsAdobeWarning` parameter:
   ```csharp
   public record RegisteredPackage(
       string LocalPackagePath,
       string ProductName,
       string ProductCode);
   ```

5. **OrphanedFile.cs** â€” Remove `IsAdobeWarning` parameter:
   ```csharp
   public record OrphanedFile(
       string FullPath,
       long SizeBytes,
       bool IsPatch)
   ```

6. **InstallerQueryService.cs** â€” Update all `new RegisteredPackage(...)` calls to remove the `IsAdobeWarning` argument.

7. **FileSystemScanService.cs** â€” Update `new OrphanedFile(...)` call to remove `IsAdobeWarning: false`.

8. **FileSystemScanServiceTests.cs** â€” Update all `RegisteredPackage` and `OrphanedFile` constructor calls to remove `IsAdobeWarning`. Delete the `FindOrphanedFilesAsync_adobe_warning_propagates_from_registered_set` test (it tested Phase 2 behaviour).

**Verify:** `dotnet test src/SimpleWindowsInstallerCleaner.Tests` â€” all remaining tests pass.

**Commit:** `refactor: remove Phase 2 component scan and IsAdobeWarning`

---

## Task 2: Add settings service

**Why:** Need to persist move destination, exclusion filters, and preferences between sessions.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/Models/AppSettings.cs`
- `src/SimpleWindowsInstallerCleaner/Services/ISettingsService.cs`
- `src/SimpleWindowsInstallerCleaner/Services/SettingsService.cs`
- `src/SimpleWindowsInstallerCleaner.Tests/Services/SettingsServiceTests.cs`

**AppSettings.cs:**
```csharp
namespace SimpleWindowsInstallerCleaner.Models;

public sealed class AppSettings
{
    public string MoveDestination { get; set; } = string.Empty;
    public List<string> ExclusionFilters { get; set; } = new() { "Adobe", "Acrobat" };
    public bool CheckPendingReboot { get; set; } = true;
}
```

**ISettingsService.cs:**
```csharp
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public interface ISettingsService
{
    AppSettings Load();
    void Save(AppSettings settings);
}
```

**SettingsService.cs:**
```csharp
using System.Text.Json;
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public sealed class SettingsService : ISettingsService
{
    private static readonly string SettingsFolder = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        "NoFaff", "SimpleWindowsInstallerCleaner");

    private static readonly string SettingsFile = Path.Combine(SettingsFolder, "settings.json");

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    public AppSettings Load()
    {
        try
        {
            if (!File.Exists(SettingsFile))
                return new AppSettings();

            var json = File.ReadAllText(SettingsFile);
            return JsonSerializer.Deserialize<AppSettings>(json, JsonOptions) ?? new AppSettings();
        }
        catch
        {
            return new AppSettings();
        }
    }

    public void Save(AppSettings settings)
    {
        Directory.CreateDirectory(SettingsFolder);
        var json = JsonSerializer.Serialize(settings, JsonOptions);
        File.WriteAllText(SettingsFile, json);
    }
}
```

**SettingsServiceTests.cs** â€” test round-trip save/load using a temp directory. Use an internal constructor or inject the file path for testability. Alternatively, test via the actual `SettingsService` with a temp `LOCALAPPDATA` override. Simplest: make `SettingsService` accept an optional path override in an internal constructor (same pattern as `FileSystemScanService`):

```csharp
// Add to SettingsService:
private readonly string _settingsFile;

public SettingsService() : this(SettingsFile) { }

internal SettingsService(string settingsFile)
{
    _settingsFile = settingsFile;
}
// Then use _settingsFile instead of SettingsFile in Load() and Save().
```

**Tests:**
1. `Load_returns_defaults_when_no_file_exists` â€” new service with nonexistent path â†’ default settings with "Adobe", "Acrobat" filters
2. `Save_then_Load_round_trips` â€” save custom settings, load, verify all fields match
3. `Load_returns_defaults_when_file_is_corrupt` â€” write garbage to file, load â†’ defaults

**Verify:** `dotnet test src/SimpleWindowsInstallerCleaner.Tests`

**Commit:** `feat: add settings service with JSON persistence`

---

## Task 3: Add exclusion filter service

**Why:** Files matching exclusion patterns should be separated from actionable orphans.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/Services/IExclusionService.cs`
- `src/SimpleWindowsInstallerCleaner/Services/ExclusionService.cs`
- `src/SimpleWindowsInstallerCleaner.Tests/Services/ExclusionServiceTests.cs`

**IExclusionService.cs:**
```csharp
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public interface IExclusionService
{
    FilteredResult ApplyFilters(IReadOnlyList<OrphanedFile> files, IReadOnlyList<string> filters);
}

public record FilteredResult(
    IReadOnlyList<OrphanedFile> Actionable,
    IReadOnlyList<OrphanedFile> Excluded);
```

**ExclusionService.cs:**

The filter logic: for each orphaned file, check if the filename contains any of the filter strings (case-insensitive). If yes â†’ excluded. If no â†’ actionable.

```csharp
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public sealed class ExclusionService : IExclusionService
{
    public FilteredResult ApplyFilters(IReadOnlyList<OrphanedFile> files, IReadOnlyList<string> filters)
    {
        if (filters.Count == 0)
            return new FilteredResult(files, Array.Empty<OrphanedFile>());

        var actionable = new List<OrphanedFile>();
        var excluded = new List<OrphanedFile>();

        foreach (var file in files)
        {
            var isExcluded = filters.Any(f =>
                file.FileName.Contains(f, StringComparison.OrdinalIgnoreCase));

            if (isExcluded)
                excluded.Add(file);
            else
                actionable.Add(file);
        }

        return new FilteredResult(actionable.AsReadOnly(), excluded.AsReadOnly());
    }
}
```

**Tests:**
1. `ApplyFilters_separates_matching_files` â€” files with "Adobe" in name go to Excluded
2. `ApplyFilters_is_case_insensitive` â€” "adobe" filter matches "ADOBE_PATCH.msp"
3. `ApplyFilters_with_no_filters_returns_all_as_actionable`
4. `ApplyFilters_with_multiple_filters` â€” "Adobe" and "Acrobat" both match their respective files
5. `ApplyFilters_no_match_returns_all_actionable` â€” files that don't match any filter

**Verify:** `dotnet test src/SimpleWindowsInstallerCleaner.Tests`

**Commit:** `feat: add exclusion filter service with tests`

---

## Task 4: Add pending reboot check

**Why:** If Windows has pending updates, moving installer files could be unsafe.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/Services/IPendingRebootService.cs`
- `src/SimpleWindowsInstallerCleaner/Services/PendingRebootService.cs`

**IPendingRebootService.cs:**
```csharp
namespace SimpleWindowsInstallerCleaner.Services;

public interface IPendingRebootService
{
    bool HasPendingReboot();
}
```

**PendingRebootService.cs:**
```csharp
using Microsoft.Win32;

namespace SimpleWindowsInstallerCleaner.Services;

public sealed class PendingRebootService : IPendingRebootService
{
    public bool HasPendingReboot()
    {
        try
        {
            using var key = Registry.LocalMachine.OpenSubKey(
                @"SYSTEM\CurrentControlSet\Control\Session Manager");

            if (key is null)
                return false;

            var value = key.GetValue("PendingFileRenameOperations");
            if (value is string[] ops)
                return ops.Length > 0;

            return value is not null;
        }
        catch
        {
            return false; // fail open â€” don't block the user
        }
    }
}
```

No unit tests for this one â€” it reads real registry state. Testability is via the interface (mock in VM tests).

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: add pending reboot detection service`

---

## Task 5: Add delete files service

**Why:** Users expect a delete option alongside move.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/Services/IDeleteFilesService.cs`
- `src/SimpleWindowsInstallerCleaner/Services/DeleteFilesService.cs`
- `src/SimpleWindowsInstallerCleaner.Tests/Services/DeleteFilesServiceTests.cs`

**IDeleteFilesService.cs:**
```csharp
namespace SimpleWindowsInstallerCleaner.Services;

public interface IDeleteFilesService
{
    Task<DeleteResult> DeleteFilesAsync(
        IEnumerable<string> filePaths,
        IProgress<string>? progress = null,
        CancellationToken cancellationToken = default);
}

public record DeleteResult(int DeletedCount, IReadOnlyList<DeleteError> Errors);
public record DeleteError(string FilePath, string Message);
```

**DeleteFilesService.cs** â€” Same pattern as `MoveFilesService`. `File.Delete()` in a `Task.Run` loop, catch exceptions per-file.

**Tests** (same pattern as MoveFilesServiceTests, using temp files):
1. `DeleteFilesAsync_deletes_file` â€” file gone, no errors
2. `DeleteFilesAsync_reports_error_for_missing_source` â€” nonexistent file â†’ error

**Verify:** `dotnet test src/SimpleWindowsInstallerCleaner.Tests`

**Commit:** `feat: add delete files service with tests`

---

## Task 6: Add MSI Summary Information reader

**Why:** Needed for the details view and for richer exclusion filtering (Author, Title, Subject, Digital Signature). This gives feature parity with PatchCleaner.

This is the trickiest task. The approach uses `MsiGetSummaryInformation` and `MsiSummaryInfoGetProperty` from msi.dll â€” consistent with the existing P/Invoke pattern. No raw COM interop needed.

**Files to create/modify:**
- Modify: `src/SimpleWindowsInstallerCleaner/Interop/MsiNativeMethods.cs` â€” add new P/Invoke declarations
- Create: `src/SimpleWindowsInstallerCleaner/Models/MsiSummaryInfo.cs`
- Create: `src/SimpleWindowsInstallerCleaner/Services/IMsiFileInfoService.cs`
- Create: `src/SimpleWindowsInstallerCleaner/Services/MsiFileInfoService.cs`

### P/Invoke declarations to add to MsiNativeMethods.cs:

```csharp
/// <summary>
/// Opens the summary information stream of an MSI/MSP file.
/// Pass hDatabase = 0 and szDatabasePath = file path to open from a file.
/// </summary>
[DllImport(MsiLib, EntryPoint = "MsiGetSummaryInformationW", CharSet = CharSet.Unicode)]
public static extern uint MsiGetSummaryInformation(
    IntPtr hDatabase,
    string? szDatabasePath,
    uint uiUpdateCount,
    out IntPtr phSummaryInfo);

/// <summary>
/// Retrieves a property from the summary information stream.
/// </summary>
[DllImport(MsiLib, EntryPoint = "MsiSummaryInfoGetPropertyW", CharSet = CharSet.Unicode)]
public static extern uint MsiSummaryInfoGetProperty(
    IntPtr hSummaryInfo,
    uint uiProperty,
    out uint puiDataType,
    out int piValue,
    IntPtr pftValue,
    StringBuilder? szValueBuf,
    ref uint pcchValueBuf);

/// <summary>
/// Closes an MSI handle (summary info, database, etc).
/// </summary>
[DllImport(MsiLib, EntryPoint = "MsiCloseHandle")]
public static extern uint MsiCloseHandle(IntPtr hAny);
```

### Summary Information property IDs (add as constants or a static class):

```csharp
/// <summary>
/// Property IDs for MsiSummaryInfoGetProperty.
/// </summary>
public static class MsiSummaryProperty
{
    public const uint Title    = 2;  // PID_TITLE
    public const uint Subject  = 3;  // PID_SUBJECT
    public const uint Author   = 4;  // PID_AUTHOR
    public const uint Comments = 6;  // PID_COMMENTS
}
```

Add `MsiSummaryProperty` to `MsiConstants.cs`.

### VT type constants (for interpreting puiDataType):

```csharp
// Add to MsiConstants.cs or inline in the service
public static class VtType
{
    public const uint Empty  = 0;
    public const uint String = 30; // VT_LPSTR
}
```

### MsiSummaryInfo model:

```csharp
namespace SimpleWindowsInstallerCleaner.Models;

/// <summary>
/// Metadata read from an MSI/MSP file's Summary Information Stream.
/// </summary>
public record MsiSummaryInfo(
    string Title,
    string Subject,
    string Author,
    string Comments,
    string DigitalSignature);
```

### MsiFileInfoService:

```csharp
using System.Security.Cryptography.X509Certificates;
using System.Text;
using SimpleWindowsInstallerCleaner.Interop;
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public interface IMsiFileInfoService
{
    MsiSummaryInfo? GetSummaryInfo(string filePath);
}

public sealed class MsiFileInfoService : IMsiFileInfoService
{
    public MsiSummaryInfo? GetSummaryInfo(string filePath)
    {
        IntPtr hSummary = IntPtr.Zero;
        try
        {
            var error = MsiNativeMethods.MsiGetSummaryInformation(
                IntPtr.Zero, filePath, 0, out hSummary);

            if (error != MsiError.Success)
                return null;

            var title   = GetStringProperty(hSummary, MsiSummaryProperty.Title);
            var subject = GetStringProperty(hSummary, MsiSummaryProperty.Subject);
            var author  = GetStringProperty(hSummary, MsiSummaryProperty.Author);
            var comments= GetStringProperty(hSummary, MsiSummaryProperty.Comments);
            var sig     = GetDigitalSignature(filePath);

            return new MsiSummaryInfo(title, subject, author, comments, sig);
        }
        catch
        {
            return null;
        }
        finally
        {
            if (hSummary != IntPtr.Zero)
                MsiNativeMethods.MsiCloseHandle(hSummary);
        }
    }

    private static string GetStringProperty(IntPtr hSummary, uint propertyId)
    {
        uint dataType;
        int intValue;
        uint bufferLen = 0;

        // First call: get required buffer size
        var error = MsiNativeMethods.MsiSummaryInfoGetProperty(
            hSummary, propertyId,
            out dataType, out intValue, IntPtr.Zero,
            null, ref bufferLen);

        if (dataType != VtType.String || bufferLen == 0)
            return string.Empty;

        bufferLen++; // null terminator
        var buffer = new StringBuilder((int)bufferLen);

        error = MsiNativeMethods.MsiSummaryInfoGetProperty(
            hSummary, propertyId,
            out dataType, out intValue, IntPtr.Zero,
            buffer, ref bufferLen);

        return error == MsiError.Success ? buffer.ToString() : string.Empty;
    }

    private static string GetDigitalSignature(string filePath)
    {
        try
        {
            var cert = X509Certificate.CreateFromSignedFile(filePath);
            // Extract CN from subject, e.g. "CN=Microsoft Corporation, O=..."
            var subject = cert.Subject;
            var cnStart = subject.IndexOf("CN=", StringComparison.OrdinalIgnoreCase);
            if (cnStart >= 0)
            {
                cnStart += 3;
                var cnEnd = subject.IndexOf(',', cnStart);
                return cnEnd >= 0 ? subject[cnStart..cnEnd].Trim() : subject[cnStart..].Trim();
            }
            return subject;
        }
        catch
        {
            return string.Empty;
        }
    }
}
```

**Important note for Sonnet:** The `MsiGetSummaryInformation` first call with `bufferLen = 0` may return `ERROR_MORE_DATA` (234) rather than `ERROR_SUCCESS`. Handle both â€” check `if (error != MsiError.Success && error != MsiError.MoreData) return string.Empty;` in `GetStringProperty`, same as the existing double-call pattern elsewhere in the codebase.

**No unit tests for this service** â€” it reads real MSI files. Testability is via the interface.

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: add MSI summary information reader via P/Invoke`

---

## Task 7: Update scan to return full results

**Why:** The main window needs: registered count/size, orphaned files, excluded files. Currently `FileSystemScanService` only returns orphaned files.

**Files to create/modify:**
- Create: `src/SimpleWindowsInstallerCleaner/Models/ScanResult.cs`
- Modify: `src/SimpleWindowsInstallerCleaner/Services/IFileSystemScanService.cs`
- Modify: `src/SimpleWindowsInstallerCleaner/Services/FileSystemScanService.cs`
- Modify: `src/SimpleWindowsInstallerCleaner.Tests/Services/FileSystemScanServiceTests.cs`

**ScanResult.cs:**
```csharp
namespace SimpleWindowsInstallerCleaner.Models;

public record ScanResult(
    IReadOnlyList<OrphanedFile> OrphanedFiles,
    int RegisteredFileCount,
    long RegisteredTotalBytes);
```

Note: exclusion filtering happens in the ViewModel layer (using `IExclusionService`), not in the scan. The scan returns all orphans; the VM splits them into actionable vs excluded. This keeps concerns separated.

**IFileSystemScanService.cs** â€” change return type:
```csharp
public interface IFileSystemScanService
{
    Task<ScanResult> ScanAsync(
        IProgress<string>? progress = null,
        CancellationToken cancellationToken = default);
}
```

**FileSystemScanService.cs** â€” the method now also counts registered files on disk:

After getting `registered` from the query service and building the `registeredPaths` set, enumerate the registered files' sizes:

```csharp
// Count and size registered files that exist on disk
int registeredCount = 0;
long registeredBytes = 0;
foreach (var pkg in registered)
{
    try
    {
        if (File.Exists(pkg.LocalPackagePath))
        {
            registeredCount++;
            registeredBytes += new FileInfo(pkg.LocalPackagePath).Length;
        }
    }
    catch { /* skip inaccessible */ }
}
```

Return `new ScanResult(orphans.AsReadOnly(), registeredCount, registeredBytes)`.

The `internal` test constructor with `overrideFiles` stays â€” it still works, the test just needs to be updated for the new return type.

**Update tests:**
- Change all `FindOrphanedFilesAsync()` calls to `ScanAsync()`
- Change assertions from `orphans[0].FullPath` to `result.OrphanedFiles[0].FullPath` etc.
- Add a test for registered file counting (mock returns 2 registered, 1 orphaned â†’ verify `RegisteredFileCount == 2`)
  - Note: this test can't verify `RegisteredTotalBytes` easily since the files don't exist on disk in tests. That's fine â€” just verify the count is 0 (files don't exist) and the orphan list is correct.

**Verify:** `dotnet test src/SimpleWindowsInstallerCleaner.Tests`

**Commit:** `refactor: scan service returns ScanResult with registered file stats`

---

## Task 8: Rewrite MainViewModel for compact summary UI

**Why:** The current VM drives a file-list UI. The new VM drives a compact summary with details drill-down.

**Files to modify:**
- `src/SimpleWindowsInstallerCleaner/ViewModels/MainViewModel.cs` â€” full rewrite
- `src/SimpleWindowsInstallerCleaner/ViewModels/OrphanedFileViewModel.cs` â€” keep as-is (used in details window)
- `src/SimpleWindowsInstallerCleaner/App.xaml.cs` â€” update composition root

**MainViewModel dependencies (constructor injection):**
```csharp
public MainViewModel(
    IFileSystemScanService scanService,
    IMoveFilesService moveService,
    IDeleteFilesService deleteService,
    IExclusionService exclusionService,
    ISettingsService settingsService,
    IPendingRebootService rebootService)
```

**Observable properties:**

```csharp
// Scan state
[ObservableProperty] private bool _isScanning;
[ObservableProperty] private string _scanProgress = string.Empty;

// Summary line data
[ObservableProperty] private int _registeredFileCount;
[ObservableProperty] private string _registeredSizeDisplay = string.Empty;
[ObservableProperty] private int _excludedFileCount;
[ObservableProperty] private string _excludedSizeDisplay = string.Empty;
[ObservableProperty] private int _orphanedFileCount;
[ObservableProperty] private string _orphanedSizeDisplay = string.Empty;

// Pending reboot
[ObservableProperty] private bool _hasPendingReboot;

// Move destination (persisted)
[ObservableProperty] private string _moveDestination = string.Empty;

// Busy state for move/delete operations
[ObservableProperty] private bool _isOperating;
[ObservableProperty] private string _operationProgress = string.Empty;

// Whether scan has completed at least once
[ObservableProperty] private bool _hasScanned;
```

**Internal state (not observable):**
```csharp
private ScanResult? _lastScanResult;
private FilteredResult? _lastFilteredResult;
private AppSettings _settings = null!;
```

**Commands:**

1. `ScanAsync()` â€” auto-invoked on startup:
   - Check pending reboot (if setting enabled) â†’ set `HasPendingReboot`
   - Call `scanService.ScanAsync()`
   - Apply exclusion filters via `exclusionService.ApplyFilters()`
   - Update all summary properties
   - Store results for details window

2. `BrowseDestination()` â€” opens `OpenFolderDialog`, sets `MoveDestination`, saves settings

3. `MoveAllAsync()` â€” moves all actionable (non-excluded) orphaned files:
   - Uses the actionable list from `_lastFilteredResult`
   - Shows progress
   - On completion, re-runs scan to refresh counts

4. `DeleteAllAsync()` â€” deletes all actionable orphaned files:
   - **Shows confirmation dialog first** (important!): "Permanently delete {count} files ({size})? This cannot be undone."
   - On confirmation, deletes via `deleteService`
   - On completion, re-runs scan

5. `OpenOrphanedDetails()` â€” opens the orphaned files detail window (Task 10)

6. `OpenSettings()` â€” opens settings dialog (Task 11)

7. `RefreshAsync()` â€” re-runs scan (same as ScanAsync, but can be triggered by user)

**Startup sequence** (call from `App.xaml.cs` after showing the window):
```csharp
// In App.xaml.cs OnStartup, after window.Show():
_ = viewModel.ScanCommand.ExecuteAsync(null);
```

**Helper method for size formatting** â€” extract to a static helper since it's used in multiple places:
```csharp
internal static string FormatSize(long bytes) => bytes switch
{
    >= 1_073_741_824 => $"{bytes / 1_073_741_824.0:F2} GB",
    >= 1_048_576     => $"{bytes / 1_048_576.0:F1} MB",
    >= 1_024         => $"{bytes / 1_024.0:F1} KB",
    _                => $"{bytes} B"
};
```

Use 2 decimal places for GB (matches PatchCleaner: "2.36 Gb"), 1 for MB/KB.

**`CanMove` / `CanDelete`:** Enabled when `!IsScanning && !IsOperating && OrphanedFileCount > 0`. For Move, also require `!string.IsNullOrWhiteSpace(MoveDestination)`.

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: rewrite MainViewModel for compact summary UI`

---

## Task 9: Rewrite MainWindow XAML (compact summary)

**Why:** Replace the file-list UI with the compact PatchCleaner-style summary.

**Files to modify:**
- `src/SimpleWindowsInstallerCleaner/MainWindow.xaml` â€” full rewrite
- `src/SimpleWindowsInstallerCleaner/MainWindow.xaml.cs` â€” minimal changes

**Window properties:**
```xml
Title="Simple Windows installer cleaner"
Width="700" Height="320"
MinWidth="500" MinHeight="280"
ResizeMode="CanMinimize"
WindowStartupLocation="CenterScreen"
Background="#F5F5F5"
```

Note: `ResizeMode="CanMinimize"` â€” the compact summary doesn't benefit from resizing. PatchCleaner did the same.

**Layout structure:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Title bar: "Simple Windows installer cleaner"]            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   (pending reboot warning banner â€” only when applicable)    â”‚
â”‚                                                             â”‚
â”‚   â— {count} files still used                    {size}      â”‚
â”‚   â— {count} files excluded by filters           {size}      â”‚
â”‚   â— {count} files orphaned                      {size}  â€º   â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ {move destination path}               â”‚ â”‚ Browse...    â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   Move   â”‚                              â”‚    Delete    â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                             â”‚
â”‚  âš™ Settings                      â™¥ Donate   no-faff.github â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Specific XAML guidance:**

1. **Pending reboot banner:** Yellow background (`#FFF3CD`), dark text (`#856404`), icon + "Windows has pending updates. Restart your computer before moving or deleting installer files." Visibility bound to `HasPendingReboot`. Use `BooleanToVisibilityConverter`.

2. **Three summary lines:** Use a `StackPanel` with three rows. Each row is a `DockPanel`:
   - Left: bullet (â—) + descriptive text
   - Right: size display, right-aligned
   - The orphaned line has an additional `Button` styled as a text link ("details..." or "â€º") that opens the details window

3. **Move destination:** `TextBox` (read-only, showing path) + "Browse..." button. The TextBox should show placeholder text "Choose a destination..." when empty.

4. **Move button:** Accent colour (e.g. `#0078D4` â€” Windows blue). White text. Prominent.

5. **Delete button:** Neutral/subtle styling. Not red (too alarming for a valid action) â€” use default button style but right-aligned. The confirmation dialog provides the safety.

6. **Bottom bar:** Left: "âš™ Settings" button (text-style). Right: website link.

7. **Scanning overlay:** When `IsScanning` is true, show a semi-transparent overlay with progress bar and `ScanProgress` text. Same pattern as the current code but positioned over the summary area.

8. **Operation overlay:** When `IsOperating` is true, overlay with progress text.

**Do not include:** File list in the main window. That's the details window (Task 10).

**Empty/initial state:** Before first scan completes, the three summary lines show "â€”" for counts and sizes. The scanning overlay appears immediately on startup.

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: redesign main window as compact summary`

---

## Task 10: Add orphaned files details window

**Why:** Users need to see and optionally deselect individual files before moving/deleting.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/OrphanedFilesWindow.xaml`
- `src/SimpleWindowsInstallerCleaner/OrphanedFilesWindow.xaml.cs`
- `src/SimpleWindowsInstallerCleaner/ViewModels/OrphanedFilesViewModel.cs`

**OrphanedFilesViewModel:** Takes the actionable and excluded `OrphanedFile` lists, wraps actionable in `OrphanedFileViewModel` (with `IsSelected = true` by default), and provides the excluded list separately.

Properties:
- `ObservableCollection<OrphanedFileViewModel> ActionableFiles`
- `IReadOnlyList<OrphanedFile> ExcludedFiles`
- `string SelectedSummary` â€” e.g. "12 selected (847.2 MB)"
- Commands: `SelectAll`, `SelectNone`

**Window layout (~600Ã—450):**
```
â”Œâ”€ Orphaned files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ã—â”€â”
â”‚                                                       â”‚
â”‚  â˜‘ filename.msi          14.2 MB    .msi              â”‚
â”‚  â˜‘ patch123.msp           8.1 MB    .msp              â”‚
â”‚  â˜‘ update.msi            22.8 MB    .msi              â”‚
â”‚  â”€â”€â”€ Excluded by filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
â”‚  â—» AcrobatPatch.msp       2.4 MB    .msp              â”‚
â”‚                                                       â”‚
â”‚  Select all Â· Select none     12 selected (847.2 MB)  â”‚
â”‚                                                       â”‚
â”‚                                          [Close]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Actionable files: checkboxes, selectable
- Excluded files: shown below a separator, greyed out, no checkboxes, not selectable
- Sorted by size descending within each group
- Columns: checkbox (actionable only), filename, size, type (.msi/.msp)

**Integration with MainViewModel:**
- `OpenOrphanedDetails` command creates and shows this window
- When the window closes, `MainViewModel` reads back which files are selected
- Move/Delete then operates only on selected files (not all actionable files)
- Store the selection state so that if the user opens details, deselects some, closes, then clicks Move â€” only the selected ones are moved

Actually â€” simpler approach: the **details window is informational** for v1.0. Move/Delete on the main window always operates on all actionable (non-excluded) files. The details window shows what will be affected. Per-file deselection is a nice-to-have but adds significant complexity (syncing state between windows). **Skip per-file selection for v1.0.** The details window is read-only â€” it shows what's orphaned and what's excluded. This matches PatchCleaner's details window which was also read-only.

**Revised approach:** The details window is read-only. No checkboxes. Just a list showing what's orphaned and what's excluded. This is simpler and matches PatchCleaner.

```
â”Œâ”€ Orphaned files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ã—â”€â”
â”‚                                                       â”‚
â”‚  filename.msi              14.2 MB    .msi            â”‚
â”‚  patch123.msp               8.1 MB    .msp            â”‚
â”‚  update.msi                22.8 MB    .msi            â”‚
â”‚                                                       â”‚
â”‚  â”€â”€â”€ Excluded by filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  AcrobatPatch.msp           2.4 MB    .msp            â”‚
â”‚                                                       â”‚
â”‚  3 orphaned (45.1 MB) Â· 1 excluded (2.4 MB)          â”‚
â”‚                                          [Close]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Keep `OrphanedFileViewModel` for future use but the details window uses a simpler binding directly to `OrphanedFile`.

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: add orphaned files details window`

---

## Task 11: Add settings dialog

**Why:** Users need to manage exclusion filters and toggle pending reboot check.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/SettingsWindow.xaml`
- `src/SimpleWindowsInstallerCleaner/SettingsWindow.xaml.cs`
- `src/SimpleWindowsInstallerCleaner/ViewModels/SettingsViewModel.cs`

**SettingsViewModel:**
- `ObservableCollection<string> Filters` â€” current exclusion filters
- `string NewFilter` â€” text input for adding a filter
- `bool CheckPendingReboot` â€” toggle
- Commands: `AddFilter`, `RemoveFilter(string)`, `Save`, `Cancel`
- `Save` writes to `ISettingsService` and closes the dialog (set `DialogResult = true`)
- `Cancel` closes without saving

**Window layout (~450Ã—350):**
```
â”Œâ”€ Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ã—â”€â”
â”‚                                                   â”‚
â”‚  Exclusion filters                                â”‚
â”‚  Files matching these terms won't be              â”‚
â”‚  moved or deleted.                                â”‚
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚                          â”‚  â”‚ Add â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Adobe                        [Ã—] â”‚             â”‚
â”‚  â”‚ Acrobat                      [Ã—] â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                   â”‚
â”‚  â˜‘ Check for pending reboots before scanning      â”‚
â”‚                                                   â”‚
â”‚                          [Save]    [Cancel]       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- The [Ã—] buttons remove individual filters
- The text input + Add button adds a new filter
- Pressing Enter in the text input also adds the filter
- Validation: don't add empty or duplicate filters

**Integration:** After saving settings, `MainViewModel` reloads settings and re-applies exclusion filters to the existing scan results (no need to re-scan).

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: add settings dialog with exclusion filter management`

---

## Task 12: Wire up composition root and auto-scan

**Why:** All services need to be wired together in App.xaml.cs.

**Files to modify:**
- `src/SimpleWindowsInstallerCleaner/App.xaml.cs`

**Updated composition root:**
```csharp
protected override void OnStartup(StartupEventArgs e)
{
    base.OnStartup(e);

    var settingsService = new SettingsService();
    var queryService = new InstallerQueryService();
    var scanService = new FileSystemScanService(queryService);
    var moveService = new MoveFilesService();
    var deleteService = new DeleteFilesService();
    var exclusionService = new ExclusionService();
    var rebootService = new PendingRebootService();
    var msiFileInfoService = new MsiFileInfoService();

    var viewModel = new MainViewModel(
        scanService, moveService, deleteService,
        exclusionService, settingsService, rebootService);

    var window = new MainWindow(viewModel);
    window.Show();

    // Auto-scan on startup
    _ = viewModel.ScanCommand.ExecuteAsync(null);
}
```

Note: `msiFileInfoService` is created but passed to the details window when needed, not to MainViewModel. Or, if the details window needs it, MainViewModel can hold a reference and pass it through. Decide based on how Task 10 was implemented.

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner` and `dotnet test src/SimpleWindowsInstallerCleaner.Tests`

**Commit:** `feat: wire up all services and enable auto-scan on startup`

---

## Task 13: Add "still used" details window

**Why:** PatchCleaner shows "86 files still used, 2.36 GB â€” details..." The details view shows registered products.

**Files to create:**
- `src/SimpleWindowsInstallerCleaner/RegisteredFilesWindow.xaml`
- `src/SimpleWindowsInstallerCleaner/RegisteredFilesWindow.xaml.cs`

**Note:** This window shows the registered packages from the last scan result. The data is already available from `IInstallerQueryService` â€” the `RegisteredPackage` records have `ProductName`, `ProductCode`, and `LocalPackagePath`.

**Required change:** `ScanResult` needs to also return the registered packages list (not just count/size). Update:
```csharp
public record ScanResult(
    IReadOnlyList<OrphanedFile> OrphanedFiles,
    IReadOnlyList<RegisteredPackage> RegisteredPackages,
    long RegisteredTotalBytes);
```

Then `RegisteredFileCount` is just `RegisteredPackages.Count`.

**Window layout (~650Ã—450):**
```
â”Œâ”€ Registered files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ã—â”€â”
â”‚                                                      â”‚
â”‚  Product name              File             Size     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  Microsoft Office 365      abc123.msi      45.2 MB   â”‚
â”‚  Visual Studio 2022        def456.msi      12.8 MB   â”‚
â”‚  Adobe Acrobat DC          patch1.msp       8.1 MB   â”‚
â”‚  ...                                                 â”‚
â”‚                                                      â”‚
â”‚  86 registered files (2.36 GB)                       â”‚
â”‚                                         [Close]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Columns: Product name, File name, Size
- Sorted by product name
- Read-only, no selection

**Add "details..." link to the "still used" summary line in MainWindow.** Same pattern as the orphaned details link.

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: add registered files details window`

---

## Task 14: Integrate MSI summary info into details windows

**Why:** PatchCleaner shows Author, Title, Subject, Comments, Digital Signature for each file.

**Changes:**
- In `OrphanedFilesWindow`: when the user clicks a file, show a details panel on the right (or below) with the summary info fields. Call `IMsiFileInfoService.GetSummaryInfo(filePath)` lazily (on selection).
- In `RegisteredFilesWindow`: same â€” click a file to see its metadata.

**Layout update for OrphanedFilesWindow (~750Ã—450, wider to accommodate details panel):**
```
â”Œâ”€ Orphaned files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ã—â”€â”
â”‚                                                             â”‚
â”‚  filename.msi          14.2 MB  â”‚  Author: Microsoft Corp   â”‚
â”‚  patch123.msp â—„â”€â”€â”€â”€     8.1 MB  â”‚  Title: Office Update     â”‚
â”‚  update.msi            22.8 MB  â”‚  Subject: Security patch   â”‚
â”‚                                 â”‚  Comment: KB5001234        â”‚
â”‚  â”€â”€â”€ Excluded â”€â”€â”€â”€â”€â”€            â”‚  Signature: Microsoft Corp â”‚
â”‚  AcrobatPatch.msp       2.4 MB  â”‚                            â”‚
â”‚                                                             â”‚
â”‚  3 orphaned (45.1 MB) Â· 1 excluded (2.4 MB)       [Close]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The right panel updates when the user selects a file in the list. If no file is selected, show "Select a file to view details."

**Cache consideration:** Reading summary info is I/O work. Cache results in a `Dictionary<string, MsiSummaryInfo?>` so each file is only read once per session. This cache lives in the details window ViewModel or in the `MsiFileInfoService` itself (with a `ConcurrentDictionary`).

**Verify:** `dotnet build src/SimpleWindowsInstallerCleaner`

**Commit:** `feat: show MSI summary info in details windows`

---

## Task 15: Polish and final verification

**Why:** Loose ends, error handling, visual consistency.

**Checklist:**

1. **Window icon** â€” Create or source a simple icon for the app. Add `<ApplicationIcon>` to csproj if you have an .ico file. If no icon is available, skip â€” it can be added later.

2. **About/info** â€” Add an info button to the main window bottom bar. Clicking it shows a simple message box:
   - "Simple Windows installer cleaner v1.0.0"
   - "Part of the No faff suite"
   - "MIT licence Â· github.com/no-faff"

3. **Donate link** â€” Add "â™¥ Donate" or similar to the bottom bar. Opens a URL in the default browser. Leave the URL as a placeholder (e.g. `https://github.com/no-faff/windows-installer-cleaner`) until the actual donate link is set up.

4. **Error handling for non-admin** â€” In `App.xaml.cs`, wrap the startup in a try-catch. If the scan fails with an access-denied error, show a MessageBox: "This app requires administrator privileges. Please right-click and choose 'Run as administrator'."

5. **Move destination placeholder** â€” When `MoveDestination` is empty, the TextBox should show watermark text "Choose a destination folder..." in grey italic.

6. **Delete confirmation** â€” Ensure the delete confirmation dialog uses `MessageBox.Show` with `YesNo` buttons and `Warning` icon. The message should read: "Permanently delete {count} files ({size})?\n\nThis cannot be undone."

7. **Move success message** â€” After move completes, show a brief status. After delete completes, show a brief status. These can be a transient status text on the main window (no separate dialog needed).

8. **Refresh** â€” The scan command should be re-executable. Add a small refresh button (ğŸ”„ or just "Refresh") near the summary lines. This just re-invokes `ScanCommand`.

9. **Keyboard shortcuts** â€” `F5` = Refresh/Scan. Standard window shortcuts (Alt+F4 etc.) handled by WPF automatically.

10. **British English check** â€” scan all user-facing strings. Must be British English, sentence case. Examples: "colour" not "color", "organise" not "organize", "cancelled" not "canceled". However, the technical terms are fine as-is (e.g. "orphaned" is correct in both).

11. **Framework-dependent publish** â€” Add a publish profile or document the command:
    ```
    dotnet publish src/SimpleWindowsInstallerCleaner -c Release --self-contained false -p:PublishSingleFile=true -o publish
    ```
    This produces a small framework-dependent single-file exe.

**Verify:**
- `dotnet test src/SimpleWindowsInstallerCleaner.Tests --verbosity normal` â€” all tests pass
- `dotnet build src/SimpleWindowsInstallerCleaner -c Release` â€” 0 errors, 0 warnings
- Manual smoke test as administrator

**Commit:** `chore: polish UI, error handling and British English check`

---

## Task 16: Update existing tests for new architecture

**Why:** The existing `FileSystemScanServiceTests` need updating for the new `ScanResult` return type and the removal of `IsAdobeWarning`. Some existing tests may have broken during earlier tasks â€” this task catches any stragglers.

**Check and fix:**
1. All `RegisteredPackage` constructors â€” 3 args now, not 4
2. All `OrphanedFile` constructors â€” 3 args now, not 4
3. All references to `FindOrphanedFilesAsync` â†’ `ScanAsync`
4. All assertions against `IsAdobeWarning` â†’ removed
5. The `Registered()` test helper â†’ updated

Run `dotnet test` and fix anything that's broken.

**Verify:** `dotnet test src/SimpleWindowsInstallerCleaner.Tests`

**Commit:** `test: update tests for new architecture`

---

## Summary of final file structure

```
src/SimpleWindowsInstallerCleaner/
  Interop/
    MsiConstants.cs              â† modified (removed MsiComponentClient, added MsiSummaryProperty, VtType)
    MsiNativeMethods.cs          â† modified (removed component APIs, added summary info APIs)
  Models/
    AppSettings.cs               â† NEW
    MsiSummaryInfo.cs            â† NEW
    OrphanedFile.cs              â† modified (removed IsAdobeWarning)
    RegisteredPackage.cs         â† modified (removed IsAdobeWarning)
    ScanResult.cs                â† NEW
  Services/
    IInstallerQueryService.cs    â† unchanged
    InstallerQueryService.cs     â† modified (Phase 2 removed)
    IFileSystemScanService.cs    â† modified (returns ScanResult)
    FileSystemScanService.cs     â† modified (returns ScanResult)
    IMoveFilesService.cs         â† unchanged
    MoveFilesService.cs          â† unchanged
    IDeleteFilesService.cs       â† NEW
    DeleteFilesService.cs        â† NEW
    IExclusionService.cs         â† NEW
    ExclusionService.cs          â† NEW
    ISettingsService.cs          â† NEW
    SettingsService.cs           â† NEW
    IPendingRebootService.cs     â† NEW
    PendingRebootService.cs      â† NEW
    IMsiFileInfoService.cs       â† NEW (interface in separate file or combined â€” up to you)
    MsiFileInfoService.cs        â† NEW
  ViewModels/
    MainViewModel.cs             â† rewritten
    OrphanedFileViewModel.cs     â† kept (may be used later for per-file selection)
    OrphanedFilesViewModel.cs    â† NEW (for details window)
    SettingsViewModel.cs         â† NEW
  MainWindow.xaml                â† rewritten
  MainWindow.xaml.cs             â† minimal changes
  OrphanedFilesWindow.xaml       â† NEW
  OrphanedFilesWindow.xaml.cs    â† NEW
  RegisteredFilesWindow.xaml     â† NEW
  RegisteredFilesWindow.xaml.cs  â† NEW
  SettingsWindow.xaml            â† NEW
  SettingsWindow.xaml.cs         â† NEW
  App.xaml                       â† unchanged
  App.xaml.cs                    â† modified (new composition root)
  app.manifest                   â† unchanged
  GlobalUsings.cs                â† unchanged

src/SimpleWindowsInstallerCleaner.Tests/
  Services/
    FileSystemScanServiceTests.cs   â† modified
    MoveFilesServiceTests.cs        â† unchanged
    ExclusionServiceTests.cs        â† NEW
    SettingsServiceTests.cs         â† NEW
    DeleteFilesServiceTests.cs      â† NEW
  PlaceholderTest.cs                â† can be deleted
```

---

## What's NOT in this plan (deferred to v1.1+)

- CLI interface
- Version update checking
- "Missing files" check
- Per-file selection in details window (all-or-nothing for v1.0)
- Undo/restore log
- Enhanced exclusion filter matching against summary info fields (v1.0 matches on filename only; v1.1 can match on Author/Title/Subject)

---

## Execution notes for Sonnet

1. **Do tasks in order.** Each task builds on the previous. Don't skip ahead.
2. **Build and test after every task.** The plan says when to verify â€” do it.
3. **Commit after every task.** Small, focused commits.
4. **Don't add features not in this plan.** No extras, no "improvements", no refactoring beyond what's specified.
5. **British English in all user-facing strings.** Sentence case. No Oxford comma.
6. **Follow existing code patterns.** The P/Invoke double-call pattern, the `Task.Run` pattern, the CommunityToolkit.Mvvm `[ObservableProperty]` / `[RelayCommand]` pattern â€” all established. Copy them.
7. **Don't over-engineer.** If the plan says a simple approach, use it. No dependency injection containers, no fancy patterns, no abstractions for one-off things.
8. **The MSI Summary Information P/Invoke in Task 6 is the hardest part.** The signatures and approach are specified precisely â€” follow them. The `MsiGetSummaryInformation` / `MsiSummaryInfoGetProperty` / `MsiCloseHandle` trio is the right approach. Do NOT use raw COM IStorage interop.
9. **Window sizing:** The main window is compact (~700Ã—300). Don't make it bigger. PatchCleaner proved that small works.
10. **When in doubt, match PatchCleaner's behaviour.** It has 870,000 downloads. The UX is proven.
