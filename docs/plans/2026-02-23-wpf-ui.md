# WPF UI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the WPF front-end for Simple Windows installer cleaner on top of the existing MSI query service, resulting in a working, installable app.

**Architecture:** The existing `InstallerQueryService` returns registered packages; a new `FileSystemScanService` enumerates `C:\Windows\Installer` and cross-references to find orphaned files. A `MainViewModel` drives the UI via MVVM, and a `MoveFilesService` handles the safe-move operation. Everything is wired together in `App.xaml.cs`.

**Tech stack:** C# 12, WPF (.NET 8), CommunityToolkit.Mvvm 8.x (MVVM helpers), xUnit + Moq (unit tests), msi.dll P/Invoke (already done).

---

## Context: what already exists

```
src/SimpleWindowsInstallerCleaner/
  Interop/
    MsiConstants.cs          ← enums + error codes
    MsiNativeMethods.cs      ← P/Invoke declarations
  Models/
    RegisteredPackage.cs     ← record: LocalPackagePath, ProductName, ProductCode, IsAdobeWarning
  Services/
    IInstallerQueryService.cs
    InstallerQueryService.cs ← full 548-line MSI API implementation
  SimpleWindowsInstallerCleaner.csproj  ← net8.0-windows, NO WPF yet
```

The service has one method:
```csharp
Task<IReadOnlyList<RegisteredPackage>> GetRegisteredPackagesAsync(
    IProgress<string>? progress = null,
    CancellationToken cancellationToken = default);
```

---

## Task 1: Convert project to WPF app

**Files:**
- Modify: `src/SimpleWindowsInstallerCleaner/SimpleWindowsInstallerCleaner.csproj`
- Create: `src/SimpleWindowsInstallerCleaner/app.manifest`
- Create: `src/SimpleWindowsInstallerCleaner/App.xaml`
- Create: `src/SimpleWindowsInstallerCleaner/App.xaml.cs`

**Step 1: Update the project file**

Replace the contents of `SimpleWindowsInstallerCleaner.csproj` with:

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
    <LangVersion>12</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>SimpleWindowsInstallerCleaner</RootNamespace>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AssemblyName>SimpleWindowsInstallerCleaner</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.*" />
  </ItemGroup>

</Project>
```

**Step 2: Create `app.manifest` (admin elevation)**

```xml
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="SimpleWindowsInstallerCleaner.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
```

**Step 3: Create `App.xaml`**

```xml
<Application x:Class="SimpleWindowsInstallerCleaner.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
</Application>
```

**Step 4: Create `App.xaml.cs`**

```csharp
using System.Windows;

namespace SimpleWindowsInstallerCleaner;

public partial class App : Application
{
}
```

**Step 5: Restore packages and verify build**

```
cd src/SimpleWindowsInstallerCleaner
dotnet restore
dotnet build
```

Expected: build succeeds with 0 errors. (No window yet — that's fine.)

**Step 6: Commit**

```
git add src/SimpleWindowsInstallerCleaner/SimpleWindowsInstallerCleaner.csproj
git add src/SimpleWindowsInstallerCleaner/app.manifest
git add src/SimpleWindowsInstallerCleaner/App.xaml
git add src/SimpleWindowsInstallerCleaner/App.xaml.cs
git commit -m "feat: convert project to WPF app with admin elevation manifest"
```

---

## Task 2: Add test project

**Files:**
- Create: `src/SimpleWindowsInstallerCleaner.Tests/SimpleWindowsInstallerCleaner.Tests.csproj`
- Create: `src/SimpleWindowsInstallerCleaner.Tests/PlaceholderTest.cs`
- Create: `src/SimpleWindowsInstallerCleaner.sln` (or add to root if one exists)

**Step 1: Create the test project**

```
dotnet new xunit -n SimpleWindowsInstallerCleaner.Tests -o src/SimpleWindowsInstallerCleaner.Tests --framework net8.0
```

**Step 2: Add project reference to the test project**

Edit `src/SimpleWindowsInstallerCleaner.Tests/SimpleWindowsInstallerCleaner.Tests.csproj` — add inside `<ItemGroup>`:

```xml
<ItemGroup>
  <ProjectReference Include="..\SimpleWindowsInstallerCleaner\SimpleWindowsInstallerCleaner.csproj" />
  <PackageReference Include="Moq" Version="4.*" />
</ItemGroup>
```

Also remove the auto-added xunit package lines and replace with explicit versions if needed (keep whatever `dotnet new xunit` generated).

**Step 3: Rename `UnitTest1.cs` to `PlaceholderTest.cs` and update**

```csharp
namespace SimpleWindowsInstallerCleaner.Tests;

public class PlaceholderTest
{
    [Fact]
    public void Placeholder_passes() => Assert.True(true);
}
```

**Step 4: Create a solution file**

```
cd src
dotnet new sln -n SimpleWindowsInstallerCleaner
dotnet sln add SimpleWindowsInstallerCleaner/SimpleWindowsInstallerCleaner.csproj
dotnet sln add SimpleWindowsInstallerCleaner.Tests/SimpleWindowsInstallerCleaner.Tests.csproj
```

**Step 5: Run tests**

```
dotnet test src/SimpleWindowsInstallerCleaner.Tests
```

Expected: 1 test passes.

**Step 6: Commit**

```
git add src/
git commit -m "feat: add xunit test project and solution file"
```

---

## Task 3: OrphanedFile model and FileSystemScanService (with tests)

**Files:**
- Create: `src/SimpleWindowsInstallerCleaner/Models/OrphanedFile.cs`
- Create: `src/SimpleWindowsInstallerCleaner/Services/IFileSystemScanService.cs`
- Create: `src/SimpleWindowsInstallerCleaner/Services/FileSystemScanService.cs`
- Create: `src/SimpleWindowsInstallerCleaner.Tests/Services/FileSystemScanServiceTests.cs`

**Step 1: Write the failing test first**

Create `src/SimpleWindowsInstallerCleaner.Tests/Services/FileSystemScanServiceTests.cs`:

```csharp
using Moq;
using SimpleWindowsInstallerCleaner.Models;
using SimpleWindowsInstallerCleaner.Services;

namespace SimpleWindowsInstallerCleaner.Tests.Services;

public class FileSystemScanServiceTests
{
    // Helper: builds a RegisteredPackage with only the path set.
    private static RegisteredPackage Registered(string path) =>
        new(path, "Test Product", "{00000000-0000-0000-0000-000000000001}", IsAdobeWarning: false);

    [Fact]
    public async Task FindOrphanedFilesAsync_returns_files_not_in_registered_set()
    {
        // Arrange
        var registered = new List<RegisteredPackage>
        {
            Registered(@"C:\Windows\Installer\aaa.msi"),
        };

        var mockQuery = new Mock<IInstallerQueryService>();
        mockQuery
            .Setup(s => s.GetRegisteredPackagesAsync(It.IsAny<IProgress<string>?>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(registered.AsReadOnly());

        // Fake filesystem: two files, one registered, one orphaned.
        var fakeFiles = new[]
        {
            @"C:\Windows\Installer\aaa.msi",   // registered — should NOT appear
            @"C:\Windows\Installer\bbb.msi",   // orphaned — should appear
        };

        var svc = new FileSystemScanService(mockQuery.Object, fakeFiles);

        // Act
        var orphans = await svc.FindOrphanedFilesAsync();

        // Assert
        Assert.Single(orphans);
        Assert.Equal(@"C:\Windows\Installer\bbb.msi", orphans[0].FullPath);
        Assert.False(orphans[0].IsAdobeWarning);
    }

    [Fact]
    public async Task FindOrphanedFilesAsync_path_comparison_is_case_insensitive()
    {
        var registered = new List<RegisteredPackage>
        {
            Registered(@"C:\Windows\Installer\AAA.MSI"),
        };

        var mockQuery = new Mock<IInstallerQueryService>();
        mockQuery
            .Setup(s => s.GetRegisteredPackagesAsync(It.IsAny<IProgress<string>?>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(registered.AsReadOnly());

        var fakeFiles = new[] { @"C:\Windows\Installer\aaa.msi" };

        var svc = new FileSystemScanService(mockQuery.Object, fakeFiles);
        var orphans = await svc.FindOrphanedFilesAsync();

        Assert.Empty(orphans);
    }

    [Fact]
    public async Task FindOrphanedFilesAsync_adobe_warning_propagates_from_registered_set()
    {
        // A file claimed only by the Adobe component path (IsAdobeWarning = true).
        var registered = new List<RegisteredPackage>
        {
            new(@"C:\Windows\Installer\adobe.msi", "Adobe Acrobat",
                "{ADOBE-GUID}", IsAdobeWarning: true),
        };

        // A second file is orphaned but its product had IsAdobeWarning set in
        // the component scan — simulate by having no entry at all (orphan).
        var mockQuery = new Mock<IInstallerQueryService>();
        mockQuery
            .Setup(s => s.GetRegisteredPackagesAsync(It.IsAny<IProgress<string>?>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(registered.AsReadOnly());

        // adobe.msi is in the registered set — should NOT appear as orphan.
        var fakeFiles = new[] { @"C:\Windows\Installer\adobe.msi" };

        var svc = new FileSystemScanService(mockQuery.Object, fakeFiles);
        var orphans = await svc.FindOrphanedFilesAsync();

        Assert.Empty(orphans);
    }
}
```

**Step 2: Run the tests to verify they fail**

```
dotnet test src/SimpleWindowsInstallerCleaner.Tests
```

Expected: compilation errors (`FileSystemScanService` doesn't exist yet).

**Step 3: Create `OrphanedFile.cs`**

```csharp
namespace SimpleWindowsInstallerCleaner.Models;

/// <summary>
/// A file found in C:\Windows\Installer that is not registered with the
/// Windows Installer API and is therefore safe to move or delete.
/// </summary>
public record OrphanedFile(
    /// <summary>Full path to the file.</summary>
    string FullPath,
    /// <summary>File size in bytes.</summary>
    long SizeBytes,
    /// <summary>True for .msp patch files; false for .msi.</summary>
    bool IsPatch,
    /// <summary>
    /// True if this file was found only in the component registration scan
    /// and appears to be Adobe-related. Shown with a caution indicator.
    /// </summary>
    bool IsAdobeWarning)
{
    /// <summary>File name without directory.</summary>
    public string FileName => Path.GetFileName(FullPath);

    /// <summary>Human-readable file size (e.g. "14.2 MB").</summary>
    public string SizeDisplay => SizeBytes switch
    {
        >= 1_073_741_824 => $"{SizeBytes / 1_073_741_824.0:F1} GB",
        >= 1_048_576 => $"{SizeBytes / 1_048_576.0:F1} MB",
        >= 1_024 => $"{SizeBytes / 1_024.0:F1} KB",
        _ => $"{SizeBytes} B"
    };
}
```

**Step 4: Create `IFileSystemScanService.cs`**

```csharp
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public interface IFileSystemScanService
{
    /// <summary>
    /// Enumerates C:\Windows\Installer, queries the MSI API to discover
    /// which files are registered, and returns those that are not.
    /// </summary>
    Task<IReadOnlyList<OrphanedFile>> FindOrphanedFilesAsync(
        IProgress<string>? progress = null,
        CancellationToken cancellationToken = default);
}
```

**Step 5: Create `FileSystemScanService.cs`**

The constructor takes an `IInstallerQueryService` and an optional `IEnumerable<string>? overrideFiles` — the override is used only in tests to inject a fake filesystem list without needing to mock `Directory.GetFiles`.

```csharp
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.Services;

public sealed class FileSystemScanService : IFileSystemScanService
{
    private static readonly string InstallerFolder =
        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Windows), "Installer");

    private readonly IInstallerQueryService _queryService;
    private readonly IEnumerable<string>? _overrideFiles;

    /// <summary>Production constructor.</summary>
    public FileSystemScanService(IInstallerQueryService queryService)
        : this(queryService, null) { }

    /// <summary>Test constructor — injects a fake file list.</summary>
    internal FileSystemScanService(IInstallerQueryService queryService, IEnumerable<string>? overrideFiles)
    {
        _queryService = queryService;
        _overrideFiles = overrideFiles;
    }

    public async Task<IReadOnlyList<OrphanedFile>> FindOrphanedFilesAsync(
        IProgress<string>? progress = null,
        CancellationToken cancellationToken = default)
    {
        progress?.Report("Querying Windows Installer API...");

        var registered = await _queryService.GetRegisteredPackagesAsync(progress, cancellationToken);

        var registeredPaths = new HashSet<string>(
            registered.Select(p => p.LocalPackagePath),
            StringComparer.OrdinalIgnoreCase);

        progress?.Report("Scanning installer cache folder...");

        var diskFiles = _overrideFiles
            ?? GetInstallerFiles();

        var orphans = new List<OrphanedFile>();

        foreach (var filePath in diskFiles)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (registeredPaths.Contains(filePath))
                continue;

            var ext = Path.GetExtension(filePath);
            if (!ext.Equals(".msi", StringComparison.OrdinalIgnoreCase)
                && !ext.Equals(".msp", StringComparison.OrdinalIgnoreCase))
                continue;

            long size = 0;
            try { size = new FileInfo(filePath).Length; } catch { /* skip inaccessible files */ }

            orphans.Add(new OrphanedFile(
                FullPath: filePath,
                SizeBytes: size,
                IsPatch: ext.Equals(".msp", StringComparison.OrdinalIgnoreCase),
                IsAdobeWarning: false));
        }

        progress?.Report($"Found {orphans.Count} orphaned file(s).");
        return orphans.AsReadOnly();
    }

    private static IEnumerable<string> GetInstallerFiles()
    {
        if (!Directory.Exists(InstallerFolder))
            return Enumerable.Empty<string>();

        return Directory.EnumerateFiles(InstallerFolder, "*.msi")
            .Concat(Directory.EnumerateFiles(InstallerFolder, "*.msp"));
    }
}
```

**Step 6: Run tests**

```
dotnet test src/SimpleWindowsInstallerCleaner.Tests
```

Expected: all 3 tests pass.

**Step 7: Commit**

```
git add src/SimpleWindowsInstallerCleaner/Models/OrphanedFile.cs
git add src/SimpleWindowsInstallerCleaner/Services/IFileSystemScanService.cs
git add src/SimpleWindowsInstallerCleaner/Services/FileSystemScanService.cs
git add src/SimpleWindowsInstallerCleaner.Tests/Services/FileSystemScanServiceTests.cs
git commit -m "feat: add OrphanedFile model and FileSystemScanService with tests"
```

---

## Task 4: MoveFilesService

**Files:**
- Create: `src/SimpleWindowsInstallerCleaner/Services/IMoveFilesService.cs`
- Create: `src/SimpleWindowsInstallerCleaner/Services/MoveFilesService.cs`
- Create: `src/SimpleWindowsInstallerCleaner.Tests/Services/MoveFilesServiceTests.cs`

**Step 1: Write the failing tests**

```csharp
using SimpleWindowsInstallerCleaner.Services;

namespace SimpleWindowsInstallerCleaner.Tests.Services;

public class MoveFilesServiceTests : IDisposable
{
    private readonly string _sourceDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
    private readonly string _destDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());

    public MoveFilesServiceTests()
    {
        Directory.CreateDirectory(_sourceDir);
        Directory.CreateDirectory(_destDir);
    }

    [Fact]
    public async Task MoveFilesAsync_moves_file_to_destination()
    {
        var file = Path.Combine(_sourceDir, "test.msi");
        await File.WriteAllTextAsync(file, "content");

        var svc = new MoveFilesService();
        var results = await svc.MoveFilesAsync(new[] { file }, _destDir);

        Assert.Empty(results.Errors);
        Assert.False(File.Exists(file));
        Assert.True(File.Exists(Path.Combine(_destDir, "test.msi")));
    }

    [Fact]
    public async Task MoveFilesAsync_handles_name_collision_by_appending_number()
    {
        var file1 = Path.Combine(_sourceDir, "test.msi");
        var existing = Path.Combine(_destDir, "test.msi");
        await File.WriteAllTextAsync(file1, "source");
        await File.WriteAllTextAsync(existing, "existing");

        var svc = new MoveFilesService();
        var results = await svc.MoveFilesAsync(new[] { file1 }, _destDir);

        Assert.Empty(results.Errors);
        Assert.True(File.Exists(Path.Combine(_destDir, "test.msi")));         // original
        Assert.True(File.Exists(Path.Combine(_destDir, "test (1).msi")));     // moved with suffix
    }

    [Fact]
    public async Task MoveFilesAsync_reports_error_for_missing_source()
    {
        var file = Path.Combine(_sourceDir, "nonexistent.msi");

        var svc = new MoveFilesService();
        var results = await svc.MoveFilesAsync(new[] { file }, _destDir);

        Assert.Single(results.Errors);
        Assert.Equal(file, results.Errors[0].FilePath);
    }

    public void Dispose()
    {
        if (Directory.Exists(_sourceDir)) Directory.Delete(_sourceDir, recursive: true);
        if (Directory.Exists(_destDir)) Directory.Delete(_destDir, recursive: true);
    }
}
```

**Step 2: Run to verify it fails**

```
dotnet test src/SimpleWindowsInstallerCleaner.Tests
```

Expected: compilation errors.

**Step 3: Create `IMoveFilesService.cs`**

```csharp
namespace SimpleWindowsInstallerCleaner.Services;

public interface IMoveFilesService
{
    Task<MoveResult> MoveFilesAsync(
        IEnumerable<string> filePaths,
        string destinationFolder,
        IProgress<string>? progress = null,
        CancellationToken cancellationToken = default);
}

public record MoveResult(
    int MovedCount,
    IReadOnlyList<MoveError> Errors);

public record MoveError(string FilePath, string Message);
```

**Step 4: Create `MoveFilesService.cs`**

```csharp
namespace SimpleWindowsInstallerCleaner.Services;

public sealed class MoveFilesService : IMoveFilesService
{
    public Task<MoveResult> MoveFilesAsync(
        IEnumerable<string> filePaths,
        string destinationFolder,
        IProgress<string>? progress = null,
        CancellationToken cancellationToken = default)
    {
        return Task.Run(() =>
        {
            Directory.CreateDirectory(destinationFolder);

            int moved = 0;
            var errors = new List<MoveError>();

            foreach (var sourcePath in filePaths)
            {
                cancellationToken.ThrowIfCancellationRequested();

                try
                {
                    var fileName = Path.GetFileName(sourcePath);
                    var destPath = GetUniqueDestPath(destinationFolder, fileName);
                    progress?.Report($"Moving {fileName}...");
                    File.Move(sourcePath, destPath);
                    moved++;
                }
                catch (Exception ex)
                {
                    errors.Add(new MoveError(sourcePath, ex.Message));
                }
            }

            return new MoveResult(moved, errors.AsReadOnly());
        }, cancellationToken);
    }

    private static string GetUniqueDestPath(string folder, string fileName)
    {
        var candidate = Path.Combine(folder, fileName);
        if (!File.Exists(candidate)) return candidate;

        var nameWithout = Path.GetFileNameWithoutExtension(fileName);
        var ext = Path.GetExtension(fileName);

        for (int i = 1; ; i++)
        {
            candidate = Path.Combine(folder, $"{nameWithout} ({i}){ext}");
            if (!File.Exists(candidate)) return candidate;
        }
    }
}
```

**Step 5: Run tests**

```
dotnet test src/SimpleWindowsInstallerCleaner.Tests
```

Expected: all tests pass (4 new + 3 from Task 3 + 1 placeholder = 8 total).

**Step 6: Commit**

```
git add src/SimpleWindowsInstallerCleaner/Services/IMoveFilesService.cs
git add src/SimpleWindowsInstallerCleaner/Services/MoveFilesService.cs
git add src/SimpleWindowsInstallerCleaner.Tests/Services/MoveFilesServiceTests.cs
git commit -m "feat: add MoveFilesService with collision handling and tests"
```

---

## Task 5: MainViewModel

**Files:**
- Create: `src/SimpleWindowsInstallerCleaner/ViewModels/OrphanedFileViewModel.cs`
- Create: `src/SimpleWindowsInstallerCleaner/ViewModels/MainViewModel.cs`

**Step 1: Create `OrphanedFileViewModel.cs`**

This wraps `OrphanedFile` and adds `IsSelected` for checkboxes.

```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using SimpleWindowsInstallerCleaner.Models;

namespace SimpleWindowsInstallerCleaner.ViewModels;

public partial class OrphanedFileViewModel : ObservableObject
{
    public OrphanedFile File { get; }

    [ObservableProperty]
    private bool _isSelected;

    public OrphanedFileViewModel(OrphanedFile file)
    {
        File = file;
    }
}
```

**Step 2: Create `MainViewModel.cs`**

```csharp
using System.Collections.ObjectModel;
using System.Windows;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SimpleWindowsInstallerCleaner.Services;

namespace SimpleWindowsInstallerCleaner.ViewModels;

public partial class MainViewModel : ObservableObject
{
    private readonly IFileSystemScanService _scanService;
    private readonly IMoveFilesService _moveService;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanMove))]
    [NotifyPropertyChangedFor(nameof(SelectedSizeDisplay))]
    private ObservableCollection<OrphanedFileViewModel> _files = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanScan))]
    [NotifyPropertyChangedFor(nameof(CanMove))]
    private bool _isBusy;

    [ObservableProperty]
    private string _statusText = "Click \"Scan\" to find orphaned files.";

    [ObservableProperty]
    private string _destinationFolder = string.Empty;

    private CancellationTokenSource? _cts;

    public bool CanScan => !IsBusy;
    public bool CanMove => !IsBusy && Files.Any(f => f.IsSelected) && !string.IsNullOrWhiteSpace(DestinationFolder);

    public string SelectedSizeDisplay
    {
        get
        {
            var bytes = Files.Where(f => f.IsSelected).Sum(f => f.File.SizeBytes);
            return bytes switch
            {
                0 => "Nothing selected",
                >= 1_073_741_824 => $"{bytes / 1_073_741_824.0:F1} GB selected",
                >= 1_048_576 => $"{bytes / 1_048_576.0:F1} MB selected",
                >= 1_024 => $"{bytes / 1_024.0:F1} KB selected",
                _ => $"{bytes} B selected"
            };
        }
    }

    public MainViewModel(IFileSystemScanService scanService, IMoveFilesService moveService)
    {
        _scanService = scanService;
        _moveService = moveService;
    }

    [RelayCommand(CanExecute = nameof(CanScan))]
    private async Task ScanAsync()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();

        IsBusy = true;
        Files.Clear();
        StatusText = "Scanning...";

        try
        {
            var progress = new Progress<string>(msg => StatusText = msg);
            var orphans = await _scanService.FindOrphanedFilesAsync(progress, _cts.Token);

            foreach (var orphan in orphans.OrderByDescending(f => f.SizeBytes))
            {
                var vm = new OrphanedFileViewModel(orphan);
                vm.PropertyChanged += (_, _) =>
                {
                    OnPropertyChanged(nameof(CanMove));
                    OnPropertyChanged(nameof(SelectedSizeDisplay));
                };
                Files.Add(vm);
            }

            StatusText = orphans.Count == 0
                ? "No orphaned files found."
                : $"Found {orphans.Count} orphaned file(s). Select files to move.";
        }
        catch (OperationCanceledException)
        {
            StatusText = "Scan cancelled.";
        }
        catch (Exception ex)
        {
            StatusText = $"Scan failed: {ex.Message}";
        }
        finally
        {
            IsBusy = false;
        }
    }

    [RelayCommand]
    private void SelectAll()
    {
        foreach (var f in Files) f.IsSelected = true;
    }

    [RelayCommand]
    private void SelectNone()
    {
        foreach (var f in Files) f.IsSelected = false;
    }

    [RelayCommand]
    private void ChooseDestination()
    {
        var dialog = new Microsoft.Win32.OpenFolderDialog
        {
            Title = "Choose destination folder for moved files"
        };
        if (dialog.ShowDialog() == true)
            DestinationFolder = dialog.FolderName;

        OnPropertyChanged(nameof(CanMove));
    }

    [RelayCommand(CanExecute = nameof(CanMove))]
    private async Task MoveSelectedAsync()
    {
        var toMove = Files.Where(f => f.IsSelected).Select(f => f.File.FullPath).ToList();

        IsBusy = true;
        StatusText = $"Moving {toMove.Count} file(s)...";

        try
        {
            var progress = new Progress<string>(msg => StatusText = msg);
            var result = await _moveService.MoveFilesAsync(toMove, DestinationFolder, progress);

            // Remove successfully moved files from the list.
            var movedSet = new HashSet<string>(toMove.Take(result.MovedCount + result.Errors.Count), StringComparer.OrdinalIgnoreCase);
            var toRemove = Files.Where(f => f.IsSelected && !result.Errors.Any(e => e.FilePath == f.File.FullPath)).ToList();
            foreach (var f in toRemove) Files.Remove(f);

            StatusText = result.Errors.Count == 0
                ? $"Moved {result.MovedCount} file(s) to {DestinationFolder}."
                : $"Moved {result.MovedCount} file(s). {result.Errors.Count} error(s) — check that the app is running as administrator.";
        }
        catch (Exception ex)
        {
            StatusText = $"Move failed: {ex.Message}";
        }
        finally
        {
            IsBusy = false;
        }
    }
}
```

**Step 3: Build to verify no errors**

```
dotnet build src/SimpleWindowsInstallerCleaner
```

Expected: 0 errors.

**Step 4: Commit**

```
git add src/SimpleWindowsInstallerCleaner/ViewModels/
git commit -m "feat: add MainViewModel and OrphanedFileViewModel"
```

---

## Task 6: MainWindow XAML

**Files:**
- Create: `src/SimpleWindowsInstallerCleaner/MainWindow.xaml`
- Create: `src/SimpleWindowsInstallerCleaner/MainWindow.xaml.cs`

**Step 1: Create `MainWindow.xaml`**

Clean, functional WPF layout: toolbar strip at top, file list in centre, status/action bar at bottom.

```xml
<Window x:Class="SimpleWindowsInstallerCleaner.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Simple Windows installer cleaner"
        Width="900" Height="600"
        MinWidth="640" MinHeight="400"
        Background="#F3F3F3">

    <Window.Resources>
        <!-- Button style -->
        <Style x:Key="PrimaryButton" TargetType="Button">
            <Setter Property="Padding" Value="16,6"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="Cursor" Value="Hand"/>
        </Style>
        <Style x:Key="SecondaryButton" TargetType="Button" BasedOn="{StaticResource PrimaryButton}">
            <Setter Property="Background" Value="#E0E0E0"/>
        </Style>

        <!-- Converter: bool → Visibility -->
        <BooleanToVisibilityConverter x:Key="BoolToVis"/>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>   <!-- toolbar -->
            <RowDefinition Height="*"/>      <!-- file list -->
            <RowDefinition Height="Auto"/>   <!-- status bar -->
        </Grid.RowDefinitions>

        <!-- ── Toolbar ─────────────────────────────────────────────────── -->
        <Border Grid.Row="0" Background="#FFFFFF" BorderBrush="#DCDCDC" BorderThickness="0,0,0,1" Padding="12,8">
            <DockPanel>
                <TextBlock DockPanel.Dock="Left"
                           Text="Simple Windows installer cleaner"
                           FontSize="15" FontWeight="SemiBold"
                           VerticalAlignment="Center" Margin="0,0,20,0"/>

                <Button DockPanel.Dock="Right"
                        Content="Scan"
                        Style="{StaticResource PrimaryButton}"
                        Command="{Binding ScanCommand}"
                        IsDefault="True"/>

                <TextBlock Text="{Binding StatusText}"
                           FontSize="12" Foreground="#555"
                           VerticalAlignment="Center"
                           TextTrimming="CharacterEllipsis"/>
            </DockPanel>
        </Border>

        <!-- ── File list ─────────────────────────────────────────────── -->
        <Grid Grid.Row="1">
            <!-- Empty state -->
            <TextBlock Text="No orphaned files found yet. Click Scan to start."
                       HorizontalAlignment="Center" VerticalAlignment="Center"
                       Foreground="#888" FontSize="13">
                <TextBlock.Style>
                    <Style TargetType="TextBlock">
                        <Style.Triggers>
                            <DataTrigger Binding="{Binding Files.Count}" Value="0">
                                <Setter Property="Visibility" Value="Visible"/>
                            </DataTrigger>
                        </Style.Triggers>
                        <Setter Property="Visibility" Value="Collapsed"/>
                    </Style>
                </TextBlock.Style>
            </TextBlock>

            <ListView ItemsSource="{Binding Files}"
                      SelectionMode="Extended"
                      BorderThickness="0"
                      Background="Transparent"
                      Visibility="{Binding Files.Count, Converter={StaticResource BoolToVis}}">
                <ListView.View>
                    <GridView>
                        <!-- Checkbox column -->
                        <GridViewColumn Width="36">
                            <GridViewColumn.CellTemplate>
                                <DataTemplate>
                                    <CheckBox IsChecked="{Binding IsSelected, Mode=TwoWay}"
                                              HorizontalAlignment="Center"/>
                                </DataTemplate>
                            </GridViewColumn.CellTemplate>
                        </GridViewColumn>

                        <!-- File name -->
                        <GridViewColumn Header="File" Width="220">
                            <GridViewColumn.CellTemplate>
                                <DataTemplate>
                                    <StackPanel Orientation="Horizontal">
                                        <TextBlock Text="{Binding File.FileName}"
                                                   ToolTip="{Binding File.FullPath}"/>
                                        <!-- Adobe caution badge -->
                                        <Border Background="#FFF3CD" CornerRadius="3"
                                                Margin="6,0,0,0" Padding="4,1"
                                                Visibility="{Binding File.IsAdobeWarning, Converter={StaticResource BoolToVis}}">
                                            <TextBlock Text="Adobe — check before moving"
                                                       FontSize="10" Foreground="#856404"/>
                                        </Border>
                                    </StackPanel>
                                </DataTemplate>
                            </GridViewColumn.CellTemplate>
                        </GridViewColumn>

                        <!-- Size -->
                        <GridViewColumn Header="Size" Width="90">
                            <GridViewColumn.CellTemplate>
                                <DataTemplate>
                                    <TextBlock Text="{Binding File.SizeDisplay}"
                                               HorizontalAlignment="Right" Margin="0,0,8,0"/>
                                </DataTemplate>
                            </GridViewColumn.CellTemplate>
                        </GridViewColumn>

                        <!-- Type -->
                        <GridViewColumn Header="Type" Width="60">
                            <GridViewColumn.CellTemplate>
                                <DataTemplate>
                                    <TextBlock>
                                        <TextBlock.Style>
                                            <Style TargetType="TextBlock">
                                                <Setter Property="Text" Value=".msi"/>
                                                <Style.Triggers>
                                                    <DataTrigger Binding="{Binding File.IsPatch}" Value="True">
                                                        <Setter Property="Text" Value=".msp"/>
                                                    </DataTrigger>
                                                </Style.Triggers>
                                            </Style>
                                        </TextBlock.Style>
                                    </TextBlock>
                                </DataTemplate>
                            </GridViewColumn.CellTemplate>
                        </GridViewColumn>

                        <!-- Full path (resizable) -->
                        <GridViewColumn Header="Path" Width="360">
                            <GridViewColumn.CellTemplate>
                                <DataTemplate>
                                    <TextBlock Text="{Binding File.FullPath}"
                                               Foreground="#666" FontSize="11"
                                               TextTrimming="CharacterEllipsis"
                                               ToolTip="{Binding File.FullPath}"/>
                                </DataTemplate>
                            </GridViewColumn.CellTemplate>
                        </GridViewColumn>
                    </GridView>
                </ListView.View>
            </ListView>
        </Grid>

        <!-- ── Status / action bar ──────────────────────────────────── -->
        <Border Grid.Row="2" Background="#FFFFFF" BorderBrush="#DCDCDC"
                BorderThickness="0,1,0,0" Padding="12,8">
            <DockPanel>
                <!-- Move button (right) -->
                <Button DockPanel.Dock="Right"
                        Content="Move selected"
                        Style="{StaticResource PrimaryButton}"
                        Command="{Binding MoveSelectedCommand}"
                        Margin="8,0,0,0"/>

                <!-- Destination folder picker -->
                <Button DockPanel.Dock="Right"
                        Content="Choose destination…"
                        Style="{StaticResource SecondaryButton}"
                        Command="{Binding ChooseDestinationCommand}"/>

                <!-- Select all / none (left) -->
                <Button DockPanel.Dock="Left"
                        Content="Select all"
                        Style="{StaticResource SecondaryButton}"
                        Command="{Binding SelectAllCommand}"
                        Margin="0,0,8,0"/>
                <Button DockPanel.Dock="Left"
                        Content="Select none"
                        Style="{StaticResource SecondaryButton}"
                        Command="{Binding SelectNoneCommand}"
                        Margin="0,0,16,0"/>

                <!-- Selected size (centre) -->
                <TextBlock Text="{Binding SelectedSizeDisplay}"
                           VerticalAlignment="Center"
                           HorizontalAlignment="Center"
                           Foreground="#444" FontSize="12"/>
            </DockPanel>
        </Border>

        <!-- Progress overlay -->
        <Border Grid.Row="0" Grid.RowSpan="3"
                Background="#80000000"
                Visibility="{Binding IsBusy, Converter={StaticResource BoolToVis}}">
            <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
                <ProgressBar IsIndeterminate="True" Width="260" Height="6" Margin="0,0,0,12"/>
                <TextBlock Text="{Binding StatusText}"
                           Foreground="White" FontSize="14" HorizontalAlignment="Center"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>
```

**Step 2: Create `MainWindow.xaml.cs`**

```csharp
using System.Windows;
using SimpleWindowsInstallerCleaner.ViewModels;

namespace SimpleWindowsInstallerCleaner;

public partial class MainWindow : Window
{
    public MainWindow(MainViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}
```

**Step 3: Wire up `App.xaml.cs`**

Replace `App.xaml.cs` with:

```csharp
using System.Windows;
using SimpleWindowsInstallerCleaner.Services;
using SimpleWindowsInstallerCleaner.ViewModels;

namespace SimpleWindowsInstallerCleaner;

public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        var queryService = new InstallerQueryService();
        var scanService = new FileSystemScanService(queryService);
        var moveService = new MoveFilesService();
        var viewModel = new MainViewModel(scanService, moveService);

        var window = new MainWindow(viewModel);
        window.Show();
    }
}
```

Also remove `StartupUri` from `App.xaml`:

```xml
<Application x:Class="SimpleWindowsInstallerCleaner.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
</Application>
```

**Step 4: Build and run**

```
dotnet build src/SimpleWindowsInstallerCleaner
dotnet run --project src/SimpleWindowsInstallerCleaner
```

Expected: window opens, click Scan (requires admin — may need to run as administrator).

**Step 5: Commit**

```
git add src/SimpleWindowsInstallerCleaner/MainWindow.xaml
git add src/SimpleWindowsInstallerCleaner/MainWindow.xaml.cs
git add src/SimpleWindowsInstallerCleaner/App.xaml
git add src/SimpleWindowsInstallerCleaner/App.xaml.cs
git commit -m "feat: add MainWindow WPF UI and wire up MVVM composition root"
```

---

## Task 7: Final verification

**Step 1: Run all tests**

```
dotnet test src/SimpleWindowsInstallerCleaner.Tests --verbosity normal
```

Expected: all tests pass.

**Step 2: Build in Release**

```
dotnet build src/SimpleWindowsInstallerCleaner -c Release
```

Expected: 0 errors, 0 warnings.

**Step 3: Smoke test as administrator**

Run the built executable as administrator, click Scan, verify:
- Progress overlay appears during scan
- Orphaned files list populates (or "No orphaned files found" shown)
- Choose destination, select files, Move selected works
- Moved files no longer appear in list

**Step 4: Commit any fixups, then tag**

```
git tag v0.1.0-alpha
```

---

## Summary of all new files

```
src/
  SimpleWindowsInstallerCleaner.sln
  SimpleWindowsInstallerCleaner/
    app.manifest
    App.xaml  (modified)
    App.xaml.cs  (modified)
    MainWindow.xaml
    MainWindow.xaml.cs
    Models/
      OrphanedFile.cs
    Services/
      IFileSystemScanService.cs
      FileSystemScanService.cs
      IMoveFilesService.cs
      MoveFilesService.cs
    ViewModels/
      OrphanedFileViewModel.cs
      MainViewModel.cs
  SimpleWindowsInstallerCleaner.Tests/
    SimpleWindowsInstallerCleaner.Tests.csproj
    PlaceholderTest.cs
    Services/
      FileSystemScanServiceTests.cs
      MoveFilesServiceTests.cs
```
